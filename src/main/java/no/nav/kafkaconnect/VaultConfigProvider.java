/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package no.nav.kafkaconnect;

import com.bettercloud.vault.VaultException;
import com.bettercloud.vault.response.LogicalResponse;
import no.nav.kafkaconnect.vault.VaultError;
import no.nav.kafkaconnect.vault.VaultUtil;
import org.apache.kafka.common.config.ConfigData;
import org.apache.kafka.common.config.provider.ConfigProvider;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.util.Collections;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

public class VaultConfigProvider implements ConfigProvider {
    private static final Logger logger = LoggerFactory.getLogger(VaultConfigProvider.class);

    @Override
    public ConfigData get(String path) {
        try {
            logger.warn("Accessing path: [{}]", path);
            LogicalResponse response = fetchPath(path);

            return new ConfigData(response.getData(), response.getRenewable() ? response.getLeaseDuration() : null);
        } catch (VaultError | VaultException vE) {
            logger.error("Could not fetch data from Vault", vE);
            return new ConfigData(Collections.emptyMap(), 5000L);
        }
    }

    private LogicalResponse fetchPath(String path) throws VaultError, VaultException {
        return VaultUtil.getInstance().getClient().logical().read(path);
    }

    @Override
    public ConfigData get(String path, Set<String> keys) {
        try {
            logger.warn("Accessing path: [{}] and keys: [{}]", path, keys);
            LogicalResponse response = fetchPath(path);
            Map<String, String> toKeep = response.getData().entrySet().stream().filter((e) -> keys.contains(e.getKey()))
                    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
            return new ConfigData(toKeep, null);
        } catch (VaultError | VaultException vE) {
            logger.error("Could not fetch data from Vault", vE);
            return new ConfigData(Collections.emptyMap(), 5000L);
        }

    }

    @Override
    public void close() throws IOException {

    }

    @Override
    public void configure(Map<String, ?> configs) {
    }
}
